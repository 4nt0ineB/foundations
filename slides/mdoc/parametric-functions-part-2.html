<!DOCTYPE html>
<html>
<head>
  <title>Parametric functions</title>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
<textarea id="source">

class: center, middle

# Parametric functions - Part 2

---
# Interpretation

<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To]
```

```scala mdoc:invisible
def map[From, To](list: List[From], update: From => To): List[To] = list.map(update)
```

--

<br>

.medium[
1. A parametric function accepts all types

1. All types must be treated .hl[IN THE SAME WAY]
]

---
# All types must be treated in the same way

<br>
<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To] =
  list match {
    case ints   : List[Int]    => ...
    case strings: List[String] => ...
    case users  : List[User]   => ...
    case _                     => ...
  }
```

---
# All types must be treated in the same way

<br>

```scala mdoc:invisible
def truncate(scale: Int, number: Double): String =
  BigDecimal(number)
    .setScale(scale, BigDecimal.RoundingMode.FLOOR)
    .toDouble
    .toString
```

.pull-left[
```scala mdoc:silent
def show[A](value: A): String =
  value match {
    case x: String => x
    case x: Double => truncate(2, x)
    case _         => "N/A"
  }
```
]
.pull-right[
```scala mdoc
show("Hello")
show(123.123456)
show(true)
```
]

---
class: medium-code
# Why? Type erasure

<br>

.large2-left[
```scala mdoc:reset:invisible
def truncate(scale: Int, number: Double): String =
  BigDecimal(number)
    .setScale(scale, BigDecimal.RoundingMode.FLOOR)
    .toDouble
    .toString
```

```scala mdoc:silent
def show[A](value: A): String =
  value match {
    case x: String       => x
    case x: Double       => truncate(2, x)
    case x: List[String] => x.mkString(",")
    case x: List[Double] => x.map(truncate(2, _)).mkString(",")
    case _               => "N/A"
  }
```
]

.small2-right[
```scala mdoc
show("Hello")
show(123.123456)
show(true)
show(List("Hello", "World"))
```
]

<br><br><br><br><br><br><br><br><br>

```scala mdoc
show(List(123.123456, 0.1234))
```

---
class: medium-code
# Why? Type erasure

<br>

```scala mdoc:reset:invisible
def truncate(scale: Int, number: Double): String =
  BigDecimal(number)
    .setScale(scale, BigDecimal.RoundingMode.FLOOR)
    .toDouble
    .toString
```

```scala mdoc:silent
def show[A](value: A): String =
       if(value.isInstanceOf[String]) value.asInstanceOf[String]
  else if(value.isInstanceOf[Double]) truncate(2, value.asInstanceOf[Double])
  else if(value.isInstanceOf[List[String]]) value.asInstanceOf[List[String]].mkString(",")
  else if(value.isInstanceOf[List[Double]]) value.asInstanceOf[List[Double]].map(truncate(2, _)).mkString(",")
  else "N/A"
```

.large-left[
```scala mdoc
List(1, 2, 3).isInstanceOf[List[String]]
```

```scala
// warning: fruitless type test: a value of type
// List[Int] cannot also be a List[String]
```
]

.medium-right[
<img src="img/foundation/list-runtime.svg" alt="List runtime" style="width:400px;"/>
]

---
class: medium-code

# Why? Weak documentation

<br>

```scala
def show[A](value: A): String =
  value match {
    case x: String       => x
    case x: Double       => truncate(2, x)
    case x: List[String] => x.mkString(",")
    case x: List[Double] => x.map(truncate(2, _)).mkString(",")
    case _               => "N/A"
  }
```

<br>

.center[
## How do you test show?
]

---
class: center, middle

# Parametric polymorphism (`map`)
# !=
# Ad hoc polymorphism (`show`)


---
# How can we implement `map`?

<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To]
```

--

.pull-right[
<img src="img/foundation/linked-list-enum-2.svg" alt="List enum" style="width:400px;"/>
]

--

<br>
<br>

.medium[
1. Always return `Nil`

1. Use `update` on the elements of `list`
]

---
# Does it compile?

<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To] =
  List(1, 2, 3)
```

---
# Does it compile?

<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To] =
  List(1, 2, 3)

// error: type mismatch;
//   found   : Int(1)
//   required: To
```

--

<br>

```scala mdoc:reset:silent
def map(list: List[Int], update: Int => Int): List[Int] =
  List(1, 2, 3)
```

---
# Does it compile?

<br>

```scala
def map[From, To](list: List[From], update: From => To): List[To] =
  List(1, 2, 3)

// error: type mismatch;
//   found   : Int(1)
//   required: To
```

<br>

```scala mdoc:reset:silent
def map(list: List[Int], update: Int => Int): List[Int] =
  List(1, 2, 3)

// [success]
```

---
# Not everything in a language is good

<br>

```scala mdoc:silent
class Spaceship {
  private def autoDestroy(): Unit =
    println("Boom!")
}

val shuttle = new Spaceship()
val method = classOf[Spaceship].getDeclaredMethod("autoDestroy")
method.setAccessible(true)
```

```scala mdoc
method.invoke(shuttle)
```

---
# Summary

<br>

.large[
* More reusable

* Caller decides which underlying type to use

* Implementation must be generic
   * better documentation
   * less tests
]

---
class: center, middle

# Exercises

.medium[`ParametricFunctionExercises.scala`]

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>
    var slideshow = remark.create({
        ratio: "16:9",
        slideNumberFormat: ''
    });
</script>
</body>
</html>