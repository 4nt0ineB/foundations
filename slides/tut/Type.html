<!DOCTYPE html>
<html>
<head>
<title>Type</title>
<meta charset="utf-8">
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
font-family: 'Yanone Kaffeesatz';
font-weight: normal;
}
.pull-left {
float: left;
width: 47%;
}
.pull-right {
float: right;
width: 47%;
}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: center, middle

# Type
Foundation of Functional Programming
<br>
<br>
`@JulienTruffaut`

---
background-image: url(img/types-1.jpg)

# Type

---
background-image: url(img/types-1-bis.jpg)

# Type cardinality

---
class: center, middle

# Cardinality of a type should **exactly** fit business requirement

---
# Type too big: |String| > # Country

```tut:silent
def getCurrency(country: String): String =
  country match {
    case "France" | "Germany" => "EUR"
    case "United Kingdom"     => "GBP"
    case "Switzerland"        => "CHF"
    case _                    => ???
  }
```

---
# Type too big: |String| > # Country

```tut:silent
def getCurrency(country: String): Option[String] =
  country match {
    case "France" | "Germany" => Some("EUR")
    case "United Kingdom"     => Some("GBP")
    case "Switzerland"        => Some("CHF")
    case _                    => None
  }
```

---
# Type just right

```tut:silent
sealed trait Country

case object France        extends Country
case object Germany       extends Country
case object UnitedKingdom extends Country
case object Switzerland   extends Country

def getCurrency(country: Country): String =
  country match {
    case France | Germany => "EUR"
    case UnitedKingdom    => "GBP"
    case Switzerland      => "CHF"
  }
```

---
# Type too big

```tut:silent
case class Person(name: String, streetNumber: Option[Int], streetName: Option[String])

def fullAddress(person: Person): Option[String] = ???
```

--
# Type just right

```tut:silent
case class Address(streetNumber: Int, streetName: String)
case class Person(name: String, address: Option[Address])

def fullAddress(address: Address): String = ???

def fullPersonAddress(person: Person): Option[String] =
  person.address.map(fullAddress)
```

---
# Type too big

```tut:silent
case class Item(id: String, quantity: Int, price: Double)

// order must have at least one item
case class Order(id: String, items: List[Item]){
  def total: Double =
    items.map(i => i.quantity * i.price).sum
}
```

--

```tut:silent
def halfPriceFirstItem(order: Order): Order = {
  val firstItem = order.items.head
  val discounted = firstItem.copy(price = firstItem.price * 0.5)
  order.copy(items = discounted :: order.items.tail)
}
```

---
# Type too big

```tut:silent
case class Item(id: String, quantity: Int, price: Double)

// order must have at least one item
case class Order(id: String, items: List[Item]){
  def total: Double =
    items.map(i => i.quantity * i.price).sum
}
```

```tut:silent
def halfPriceFirstItem(order: Order): Order = {
  order.items match {
    case Nil     => ???
    case x :: xs =>
      val discounted = x.copy(price = x.price * 0.5)
      order.copy(items = discounted :: xs)
  }
}
```

---
# Type just right

```tut:silent
import cats.data.NonEmptyList
import cats.implicits._

case class Item(id: String, quantity: Int, price: Double)

case class Order(id: String, items: NonEmptyList[Item]){
  def total: Double =
    items.foldMap(i => i.quantity * i.price)
}
```

```tut:silent
def halfPriceFirstItem(order: Order): Order = {
  val firstItem  = order.items.head
  val discounted = firstItem.copy(price = firstItem.price * 0.5)
  order.copy(items = NonEmptyList(discounted, order.items.tail))
}
```


---
# Type too small

```tut:silent
import java.util.Date
```

```tut
val fifthMarch = new Date(1551818168101L) // milliseconds precision
```

--

```tut
List(1,2,3,4).size //Int.MaxValue limit
```

--

```scala
def parseJson(json: String): Option[Json] = ??? // no error description
```

---
background-image: url(img/function.jpg)

# Function

---
class: center, middle

# A => B

---
class: center, middle

```tut:silent
val isEven: Int => Boolean =
  x => x % 2 == 0

val increment: Int => Int =
  x => x + 1
```

---
class: center, middle

# Type is a set

--

# &&

# A => B is a type

---
background-image: url(img/A-to-B-set-1.jpg)

# A => B is a set!

---
background-image: url(img/int-to-int-type-1.jpg)

# Function is a set!

---
class: center, middle

# |A => B| represents how many implementations exist

---
class: center, middle

# The smaller |A => B|, the better

---
# The smaller |A => B|, the better

```tut:silent
def getCurrency1(country: String ): Option[String] = ???

def getCurrency2(country: Country): String = ???
```

--

```scala
|getCurrency2| < |getCurrency1|
```

---
class: center, middle

# How to calculate |A => B| ?



</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9"
    });
</script>
</body>
</html>