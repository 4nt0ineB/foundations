<!DOCTYPE html>
<html>
<head>
  <title>Side Effect</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body { font-family: 'Droid Serif'; color: #333333; }
    h1 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #074548; }
    h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #6f9a9c; }
    .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    .medium { font-size: 28px; }
    .large { font-size: 36px; }
    .pull-left { float: left; width: 47%; }
    .pull-right { float: right; width: 47%; }
    .large-left { float: left; width: 57%; }
    .small-right { float: right; width: 27%; }
    .medium-right { float: right; width: 37%; }
    .footer { position: absolute; bottom: 12px; left: 45px }
    table { border-collapse: collapse; display: inline-block; }
    th, td { padding: 10px; border: 1px solid black; }
    tr:nth-child(even) {background-color: #f2f2f2;}
    .reference {
    font-size: 16px;
    position: fixed;
    left: 50%;
    bottom: 12px;
    transform: translate(-50%, -50%);
    margin: 0 auto;
    }
  </style>
</head>
<body>
<textarea id="source">

class: center, middle

<a href="https://github.com/fp-tower/foundation">
  <img src="img/solid-color-logo.svg" alt="logo" style="width:600px;"/>
</a>

<br>
<br>


# Side Effect

---
layout: true

<div class="footer">
  <a href="https://github.com/fp-tower/foundation">
    <img src="img/symbol-solid-gray-b3b3b3.svg" alt="logo" style="width:100px;"/>
  </a>
</div>

---
background-image: url(img/sideeffect/function-age.svg)

# Pure function

---
.h1[# How to do something?]

<br>

.large[
* read or write from a file

* save user in database

* send notification to user's phone

* update counter of active users
]

---
class: center, middle

# A pure function cannot DO anything
# it can only produce a VALUE

---
class: center, middle

# Functional Programming is useless *

[Simon Peyton Jones](https://www.reddit.com/r/programming/comments/25m291/simon_peyton_jones_haskell_is_useless/) co-author of haskell

???
He actually said Haskell is useless

---
class: center, middle

# What is the solution?

---
class: center, middle

# Create a VALUE that describes actions

--

# Interpret the value with side effects in Main

---
background-image: url(img/sideeffect/effects-on-edges.svg)

# Run side effects at the edges

---
### 1. Encode Description

```tut:silent
trait Description[A]
```

### 2. Define an unsafe interpreter of Description

```tut:silent
def unsafeRun[A](fa: Description[A]): A = ??? // execute action, this is not a pure function
```

### 3. Combine everything in Main

```tut:silent
object Main extends App {

  val description: Description[Unit] = ???

  unsafeRun(description)

}
```

---
class: center, middle

# Examples of description / evaluation

---
.h1[# Cooking]

.pull-left[
### 1. Secret pasta recipe (Description)

.large[
1. Boil 200 ml of water
2. Add 250 g of dry pasta
3. Wait 11 minutes
4. Drain the pasta
]
]
.pull-right[
.h3[### 2. Cook (Unsafe evaluation)]

.large[
Take the recipe and do it at home
]
]

---
background-image: url(img/sideeffect/lemon-meringue-1.svg)

.reference[[Seven Sketches in Compositionality: An Invitation to Applied Category Theory](https://arxiv.org/abs/1803.05316)]

---
background-image: url(img/sideeffect/lemon-meringue-2.svg)

# Cooking compose

.reference[[Seven Sketches in Compositionality: An Invitation to Applied Category Theory](https://arxiv.org/abs/1803.05316)]

---
.h1[# Mathematical formula]

.pull-left[
```tut
val x = 2
val y = 3
val x2 = Math.pow(x, 2)
val y2 = Math.pow(y, 2)
val z  = Math.sqrt(x2 + y2)
```
]

.pull-right[
![Right triangle](img/sideeffect/right-triangle-1.svg)
]

---

.pull-left[
# Mathematical formula

<br>

```tut
val x2 = Math.pow(x, 2)
val y2 = Math.pow(y, 2)
val z  = Math.sqrt(x2 + y2)

val z2 = Math.pow(z, 2)
```
]

.pull-right[
![Right triangle](img/sideeffect/right-triangle-2.svg)
]

.reference[[Constraints Liberate, Liberties Constrain](https://www.youtube.com/watch?v=GqmsQeSzMdw)]


---
# Executable program

.center[![Run program](img/sideeffect/program-run.svg)]

<br>

```bash
~/project/foundation ᐅ ls
LICENCE   Makefile  README.MD build.sbt exercises logo      notes     project   slides    target
```

---
# Executable program compose

.center[![Pipe program](img/sideeffect/program-pipe.svg)]

<br>

```bash
~/project/foundation ᐅ ls | grep es
exercis`es`
not`es`
slid`es`
```

---
.h1[# Separate description from execution]

<br>

.large[
*   Music
*   Architecture
*   Cooking
*   Mathematical formula
*   Docker
*   ...
]

---
class: center, middle

# How to encode actions?

---
# Method 1: Thunk

```tut:silent
import java.time.LocalDate
import scala.io.StdIn

type Thunk[A] = () => A  // Unit => A

val readLine: Thunk[String] =
  () => StdIn.readLine()

def writeLine(message: String): Thunk[Unit] =
  () => println(message)

val localDate: Thunk[LocalDate] =
  () => LocalDate.now()
```

```tut:silent
def unsafeRun[A](fa: Thunk[A]): A = fa()
```

---
# Method 1: IO

```tut:silent
class IO[A](thunk: () => A) {
  def unsafeRun(): A = thunk()
}

val readLine: IO[String] =
  new IO(() => StdIn.readLine())

def writeLine(message: String): IO[Unit] =
  new IO(() => println(message))

val localDate: IO[LocalDate] =
  new IO(() => LocalDate.now())
```

```tut
localDate
localDate.unsafeRun()
```


---
class: center, middle

# IO Exercises

`exercises.sideeffect.IOExercises.scala`

---
.h1[# IO Summary]

.large[
* An `IO` is a thunk of potentially impure code

* Composing `IO` is referentially transparent, nothing get executed

* It is better to group `IO` in a interface for testing
(see `Console` and `Clock` trait in `IOExercises`)
]

---
class: center, middle

# What are the limitations of IO?

---
background-image: url(img/sideeffect/IO.svg)

# IO cannot be introspected

---
background-image: url(img/sideeffect/IO-composition-1.svg)

# IO cannot be introspected

---
class: center, middle

# IO is probably the most primitive way to capture side effect

---
# Effect Algebra

```tut:silent
sealed trait Description[A]
object Description {
  case object ReadLine                  extends Description[String]
  case class WriteLine(message: String) extends Description[Unit]
}
```

```tut:silent
import Description._

def unsafeRun[A](fa: Description[A]): A =
  fa match {
    case ReadLine       => StdIn.readLine()
    case WriteLine(msg) => println(msg)
  }
```

---
# Effect Algebra

```tut:silent
object Main extends App {

  val action: Description[Unit] = WriteLine("Hello World")

  unsafeRun(action)

}
```

```tut
Main.main(Array.empty)
```

---
class: center, middle

# How to add new actions?

---
class: center, middle

# How to combine actions together?

---
# How to add new actions?

```tut:silent
sealed trait Description[A]
object Description {
  case object ReadLine                  extends Description[String]
  case class WriteLine(message: String) extends Description[Unit]
}
```

--

### 1. Add primitive

```scala
case object ReadInt extends Description[Int]
```

--

### 2. Somehow transform existing actions

```scala
ReadLine.map(intToString) // ideally
```

---
# Free structures (brief introduction)

```tut:invisible:silent
sealed trait FreeMap[A]

object FreeMap {
  case class Map[X, A](action: Description[X], update: X => A) extends FreeMap[A]
}
```

```scala
sealed trait FreeMap[A]

object FreeMap {
  case class Map[`X`, A](action: Description[`X`], update: `X` => A) extends FreeMap[A]
}
```

--

```tut:invisible
import Description._
import FreeMap.Map
import scala.util.Try
```

```tut:silent
def parseInt(x: String): Int = Try(x.toInt).getOrElse(-1)

val readLine: FreeMap[Int] = Map(ReadLine, parseInt)
```

--

```tut:silent
def unsafeRun[A](fa: Description[A]): A =
  fa match {
    case ReadLine       => StdIn.readLine()
    case WriteLine(msg) => println(msg)
  }

def unsafeRunFree[A](fa: FreeMap[A]): A =
  fa match {
    case Map(fa, f) => f(unsafeRun(fa))
  }
```

---
# Free translates functions to data structures (GADT)


```scala
def         readLine :                   String
case object ReadLine extends Description[String]

def         writeLine(message: String) :                   Unit
case object WriteLine(message: String) extends Description[Unit]

def        map[X, A](action: Description[X], update: X => A) :       Description[A]
case class Map[X, A](action: Description[X], update: X => A) extends     FreeMap[A]
```

---
# Interpret algebra in different ways

```tut:reset:invisible
import answers.sideeffect.IOAnswers._
```

```tut:silent
sealed trait Description[A]
object Description {
  case object ReadLine                  extends Description[String]
  case class WriteLine(message: String) extends Description[Unit]
}
```

```tut:invisible
import Description._
import scala.io.StdIn
import exercises.sideeffect.IORef
```

```tut:silent
def compileToIO[A](fa: Description[A]): IO[A] =
  fa match {
    case ReadLine       => IO.effect(StdIn.readLine())
    case WriteLine(msg) => IO.effect(println(msg))
  }

def log[A](fa: Description[A]): String =
  fa match {
    case ReadLine       => "Call ReadLine"
    case WriteLine(msg) => s"Call WriteLine with $msg"
  }

def metrics[A](fa: Description[A], countRead: IORef[Int]): IO[Unit] =
  fa match {
    case ReadLine       => countRead.modify(_ + 1).void
    case WriteLine(msg) => IO.unit
  }
```

---
# Generalised Free structures

```tut:silent
sealed trait FreeMap[F[_], A]{
  def map[B](f: A => B): FreeMap[F, B]
}

object FreeMap {
  case class Map[F[_], X, A](action: F[X], update: X => A) extends FreeMap[F, A] {
    def map[B](f: A => B): FreeMap[F, B] = Map(action, update andThen f)
  }
}
```

```tut:silent
sealed trait Random[A]

object Random {
  case object RandomInt extends Random[Int]
}

val randomInt: FreeMap[Random, Int] = FreeMap.Map(Random.RandomInt, identity[Int])

def isEven(x: Int): Boolean = x % 2 == 0

val randomBool: FreeMap[Random, Boolean] = randomInt.map(isEven)
```

---
class: center, middle

# Algebra Exercises

`exercises.sideeffect.AlgebraExercises.scala`

---
.h1[# Free Summary]

.large[
* Free translates code into data

* Easy to interpret an algebra in many ways (log, test, real, metrics)

* Complex (GADT, natural transformation, Coproduct, ...)

* Can miss some features from target effect like parallel execution, resource handling
]

---
class: center, middle

# All problems in computer science can be solved by another level of indirection

David Wheeler

---
class: center, middle

# Free is several order of magnitude more complex than IO

---
# Resources and further study

* [Seven Sketches in Compositionality: An Invitation to Applied Category Theory](https://arxiv.org/abs/1803.05316)
* [Constraints Liberate, Liberties Constrain](https://www.youtube.com/watch?v=GqmsQeSzMdw)


</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9",
        slideNumberFormat: '%current%',
        // highlightStyle: "github",
        highlightLines: true,
        highlightSpans: true,
    });
</script>
</body>
</html>
