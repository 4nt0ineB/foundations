<!DOCTYPE html>
<html>
<head>
<title>Function</title>
<meta charset="utf-8">
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
font-family: 'Yanone Kaffeesatz';
font-weight: normal;
}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: center, middle

# Function
`@JulienTruffaut`

---
class: center, middle

# A => B

---
background-image: url(../img/function.jpg)

# Function

---
background-image: url(../img/function-mapping-1.jpg)

# Function is a mapping

---
background-image: url(../img/function-mapping-2.jpg)

# Function is a mapping

---
class: center, middle

# Programming function
# !=
# Math function

---
class: center, middle

# Pure function

---
background-image: url(../img/nondeterministic-function.jpg)

# Nondeterministic

---
# Nondeterministic

```tut:silent
import scala.util.Random
```

```tut
Random.nextInt(10)
Random.nextInt(10)
Random.nextInt(10)
```

---
background-image: url(../img/partial-function-1.jpg)

# Partial function

---
background-image: url(../img/partial-function-2.jpg)

# Partial function

---
# Partial function

```tut:silent
def head(xs: List[Int]): Int = xs match {
  case Nil    => sys.error("Can't access head of empty List")
  case x :: _ => x
}
```

```tut
head(List(1,2,3))
```

```tut:fail
head(Nil)
```

---
# Partial function

```tut:silent
def sum(optX: Option[Int], optY: Option[Int]): Int =
  optX.get + optY.get
```

--

```tut
sum(Some(2), Some(3))
```

--

```tut:fail
sum(Some(2), None)
```

---
background-image: url(../img/null-function-1.jpg)

# Null

---
background-image: url(../img/null-function-2.jpg)

# Null

---
# Null

```tut:silent
sealed trait Shape

case class Circle(radius: Int) extends Shape
case class Rectangle(width: Int, height: Int) extends Shape
case class RightTriangle(width: Int, height: Int) extends Shape

def isCircle(x: Shape): Boolean = x match {
  case Circle(_)           => true
  case Rectangle(_, _)     => false
  case RightTriangle(_, _) => false
}
```

```tut
isCircle(Circle(5))
isCircle(Rectangle(5, 10))
```

```tut:fail
isCircle(null)
```

---
# Reflection

```tut:silent
def foo[A](a: A): A = a match {
  case x: Int    => (x + 1).asInstanceOf[A]
  case x: String => x.reverse.asInstanceOf[A]
  case _         => a
}
```

--

```tut
foo(5)
foo("Hello")

foo(true)
```

---
# Reflection

```tut:silent
def foo[A](a: A): A = ???
```

---
# Reflection

```tut:silent
def foo[A](a: A): A = a
```

---
background-image: url(../img/function-side-effect.jpg)

# Side effect

---
# Side effect

```tut
println("Hello")
```

---
# Side effect

```tut
scala.io.Source.fromURL("http://google.com").take(100).mkString
```

---
# Side effect

```tut:silent
var x: Int = 0

def count(): Int = {
  x = x + 1
  x
}
```

```tut
count()
count()
count()
```

---
# Pure Function

* not nondeterministic (deterministic)
* not partial (total)
* no mutation
* no exception
* no null
* no reflection
* no side effect

---
class: center, middle

# A pure function does not perform any action!

---
class: center, middle
# Exercise 1: is it a pure function?

---
# Exercise 1: is it a pure function?

```tut:silent
def plus(a: Int, b: Int): Int = a + b
```

---
# Exercise 1: is it a pure function?

```tut:silent
def div(a: Int, b: Int): Int = {
  if(b == 0) sys.error("Cannot divide by 0")
  else a / b
}
```

--

```tut
div(8, 2)
```

```tut:fail
div(8, 0)
```

---
# Exercise 1: is it a pure function?

```tut:silent
var counterTimes2 = 0
def times2(i: Int): Int = {
  counterTimes2 += 1
  i * 2
}
```

--

```tut
counterTimes2
times2(5)
counterTimes2
times2(5)
```

---
# Exercise 1: is it a pure function?

```tut:silent
import scala.util.Random

def boolToInt(b: Boolean): Int = {
  if(b) 5
  else Random.nextInt() / 2
}
```

--

```tut
boolToInt(true)
boolToInt(true)
boolToInt(false)
boolToInt(false)
```

---
# Exercise 1: is it a pure function?

```tut:silent
def mapLookup(map: Map[String, Int], key: String): Int =
  map(key)
```

--

```tut:silent
val map = Map("One" -> 1, "Two" -> 2)
```

```tut
mapLookup(map, "Two")
```

```tut:fail
mapLookup(map, "Three")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def times3(i: Int): Int = {
  println("do something here") // could be a database access or http call
  i * 3
}
```

--

```tut
val x = times3(5)
x
x
times3(5)
```

---
# Exercise 1: is it a pure function?

```tut:silent
val pi = 3.14

def circleArea(radius: Double): Double =
  radius * radius * pi
```

---
# Exercise 1: is it a pure function?

```tut:silent
def inc(xs: Array[Int]): Unit =
  for { i <- 0 to xs.length } xs(i) = xs(i) + 1
```

--

```tut:fail
inc(Array(1,2,3))
```

---
# Exercise 1: is it a pure function?

```tut:silent
def inc_v2(xs: Array[Int]): Unit =
  for { i <- xs.indices } xs(i) = xs(i) + 1
```

--

```tut:silent
val xs = Array(1, 2, 3)
```

```tut
xs

inc_v2(xs)

xs

()
```

---
# Exercise 1: is it a pure function?

```tut:silent
def incAll(value: Any): Any = value match {
  case x: Int    => x + 1
  case x: Long   => x + 1
  case x: Double => x + 1
}
```

--

```tut
incAll(1)
incAll(1L)
incAll(1.0)
```

```tut:fail
incAll("Hello")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def incAll_v2(value: Any): Any = value match {
  case x: Int    => x + 1
  case x: Long   => x + 1
  case x: Double => x + 1
  case _         => 0
}
```

```tut
incAll_v2(1)
incAll_v2(1L)
incAll_v2(1.0)
incAll_v2("Hello")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def sum(xs: List[Int]): Int = {
  var acc = 0
  xs.foreach(x => acc += x)
  acc
}
```

--

```tut
sum(List(1,3,4,5))
sum(Nil)
```

---
class: center, middle

# Why pure function?

---
# Testing

```tut:silent
var counter: Long = 1

def foo(x: Int, b: Boolean): Long = {
  counter += x
  if(b) counter *= 2
  else counter = 0
  counter
}
```

--

```tut
foo(5,  true) == 12L

foo(5, false) == 0L

foo(5,  true) == 10L
```

---
# Testing

```tut:silent
def foo(x: Int, b: Boolean): Long = ???
```

```tut:invisible
def foo(x: Int, b: Boolean): Long = 0
```

--

```tut:silent
foo(5,  true) == 12L

foo(5, false) == 0L
```

--

* no setup / dependency injection, `foo` only depends on its inputs
* order of tests does not matter
* tests can be run in parallel

---
class: center, middle

# Referentially transparent

---
# Referentially transparent

A function is referentially transparent if we can replace all the calls of the function by its output without
changing the behaviour of the program.

--

```scala
bar(foo(42), foo(42))
```

```scala
val x = foo(42)
bar(x, x)
```


---
# Refactoring / Reasoning

```tut:silent
def double(x: Int): Int = {
  println(s"Hello $x")
  x * 2
}

def combine(x: Int, y: Int): Int = {
  val a = double(x)
  val b = double(y)
  a + b
}
```

--

```tut
combine(2, 10)
```

--

```tut:silent
def combine(x: Int, y: Int): Int =
  x * 2 + y * 2
```

```tut
combine(2, 10)
```

---
# Optimisation

```tut:silent
def fibonacci(x: Int): Int = x match {
  case 0 | 1 => x
  case _     => fibonacci(x - 1) + fibonacci(x - 2)
}

def combine(x: Int, y: Int): Int = {
  val a = fibonacci(x)
  val b = fibonacci(y)
  a + b
}
```

--

```tut:silent
def combine(x: Int, y: Int): Int = {
  val a = fibonacci(x)
  if(x == y) 2 * a else a + fibonacci(y)
}
```

---
# Null

```tut:silent
def length(s: String): Int = {
  if(s == null) 0
  else s.size
}
```

--

```tut
length("Hello")
length("")
length(null)
```

---
# Exception

```tut:silent
def head(xs: List[Int]): Int = xs match {
  case Nil    => sys.error("no head of an empty list")
  case x :: _ => x
}
```

--

```tut:silent
def xs: List[Int] = List(1,2,3)

try {
  head(xs)
} catch {
  case e: Exception => 0
}
```

---
# Strong type system

* no exception
* no null
* no reflection

--

This means:

* no hole in the type system
* less forgettable runtime checks (try/catch, `if(x == null)`)
* more informative signature


---
class: center, middle

# Why function?

---
background-image: url(../img/function-composition-1.jpg)

# Function composition

---
background-image: url(../img/function-composition-2.jpg)

# Function composition

---
background-image: url(../img/function-composition-3.jpg)

# Function composition

---
background-image: url(../img/function-graph.jpg)

# Graph


---
# Cost of functional programming

--

* lost the ability to affect the external world

--

* reconsider most algorithms an data structures (no mutation)

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9"
    });
</script>
</body>
</html>