<!DOCTYPE html>
<html>
<head>
<title>Function</title>
<meta charset="utf-8">
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
font-family: 'Yanone Kaffeesatz';
font-weight: normal;
}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: center, middle

# Function
`@JulienTruffaut`

---
# Function

// TODO diagram function with domain / co-domain

---
# Combine functions

// TODO diagram pipelines
* sequential: f compose g
* fork: a => (f(a), g(a))
* join: (a, b) => f(a, b))

---
class: center, middle

# A => B

---
class: center, middle

# Programming function != Math function

---
# Pure Function

* deterministic
* no side effect
* no mutation
* no exception
* no null
* no reflection

---
# Deterministic

```tut:silent
def foo(x: Int): Int = ???
```

--

```tut:invisible
def foo(x: Int): Int = ((x + 3) * 5) % 2
```

```tut
foo(2)
foo(5)
foo(2)
foo(5)
```

---
# Side effect

* touch the external world, e.g. read/write a file, http or database call, console output
* mutation
* concurrency

--

# A function with no side effect only produce a value!

???
Things that could be considered as side effects but are often not:

* stack or heap allocation
* parallelism

---
# Referentially transparent

A function is referentially transparent if we can replace all the calls of the function by its output without
changing the behaviour of the program.

--

```tut:silent
def inc(x: Int): Int = x + 1
```

```tut
inc(5)
6
```

---
# Pure Function

* deterministic
* no side effect
* no mutation


* no exception
* no null
* no reflection

---

# Exercise 1: is it a pure function?

```tut:silent
def plus(a: Int, b: Int): Int = a + b
```

---
# Exercise 1: is it a pure function?

```tut:silent
def div(a: Int, b: Int): Int = {
  if(b == 0) sys.error("Cannot divide by 0")
  else a / b
}
```

--

```tut
div(8, 2)
```

```tut:fail
div(8, 0)
```

---
# Exercise 1: is it a pure function?

```tut:silent
var counterTimes2 = 0
def times2(i: Int): Int = {
  counterTimes2 += 1
  i * 2
}
```

--

```tut
counterTimes2
times2(5)
counterTimes2
times2(5)
```

---
# Exercise 1: is it a pure function?

```tut:silent
import scala.util.Random

def boolToInt(b: Boolean): Int = {
  if(b) 5
  else Random.nextInt() / 2
}
```

--

```tut
boolToInt(true)
boolToInt(true)
boolToInt(false)
boolToInt(false)
```

---
# Exercise 1: is it a pure function?

```tut:silent
def mapLookup(map: Map[String, Int], key: String): Int =
  map(key)
```

--

```tut:silent
val map = Map("One" -> 1, "Two" -> 2)
```

```tut
mapLookup(map, "Two")
```

```tut:fail
mapLookup(map, "Three")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def times3(i: Int): Int = {
  println("do something here") // could be a database access or http call
  i * 3
}
```

--

```tut
val x = times3(5)
x
x
times3(5)
```

---
# Exercise 1: is it a pure function?

```tut:silent
val pi = 3.14

def circleArea(radius: Double): Double =
  radius * radius * pi
```

---
# Exercise 1: is it a pure function?

```tut:silent
def inc(xs: Array[Int]): Unit =
  for { i <- 0 to xs.length } xs(i) = xs(i) + 1
```

--

```tut:fail
inc(Array(1,2,3))
```

---
# Exercise 1: is it a pure function?

```tut:silent
def inc_v2(xs: Array[Int]): Unit =
  for { i <- xs.indices } xs(i) = xs(i) + 1
```

--

```tut:silent
val xs = Array(1, 2, 3)
```

```tut
xs

inc_v2(xs)

xs

()
```

---
# Exercise 1: is it a pure function?

```tut:silent
def incAll(value: Any): Any = value match {
  case x: Int    => x + 1
  case x: Long   => x + 1
  case x: Double => x + 1
}
```

--

```tut
incAll(1)
incAll(1L)
incAll(1.0)
```

```tut:fail
incAll("Hello")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def incAll_v2(value: Any): Any = value match {
  case x: Int    => x + 1
  case x: Long   => x + 1
  case x: Double => x + 1
  case _         => 0
}
```

```tut
incAll_v2(1)
incAll_v2(1L)
incAll_v2(1.0)
incAll_v2("Hello")
```

---
# Exercise 1: is it a pure function?

```tut:silent
def sum(xs: List[Int]): Int = {
  var acc = 0
  xs.foreach(x => acc += x)
  acc
}
```

--

```tut
sum(List(1,3,4,5))
sum(Nil)
```

---
class: center, middle

# Why?

---
# Function

* deterministic
* no side effect
* no mutation
* no exception
* no null
* no reflection

---
# Testing

```tut:silent
var counter: Long = 1

def foo(x: Int, b: Boolean): Long = {
  counter += x
  if(b) counter *= 2
  else counter = 0
  counter
}
```

--

```tut
foo(5,  true) == 12L

foo(5, false) == 0L

foo(5,  true) == 10L
```

---
# Testing

```tut:silent
def foo(x: Int, b: Boolean): Long = ???
```

```tut:invisible
def foo(x: Int, b: Boolean): Long = 0
```

--

```tut:silent
foo(5,  true) == 12L

foo(5, false) == 0L
```

--

* no setup / dependency injection, `foo` only depends on its inputs
* order of tests does not matter
* tests can be run in parallel

---
# Refactoring / Reasoning

```tut:silent
def double(x: Int): Int = {
  println(s"Hello $x")
  x * 2
}

def combine(x: Int, y: Int): Int = {
  val a = double(x)
  val b = double(y)
  a + b
}
```

--

```tut
combine(2, 10)
```

--

```tut:silent
def combine(x: Int, y: Int): Int =
  x * 2 + y * 2
```

```tut
combine(2, 10)
```

---
# Optimisation

// TODO


---
# Null

```tut:silent
def length(s: String): Int = {
  if(s == null) 0
  else s.size
}
```

--

```tut
length("Hello")
length("")
length(null)
```

---
# Exception

```tut:silent
def head(xs: List[Int]): Int = xs match {
  case Nil    => sys.error("no head of an empty list")
  case x :: _ => x
}
```

--

```tut:silent
def xs: List[Int] = List(1,2,3)

try {
  head(xs)
} catch {
  case e: Exception => 0
}
```

---
# Strong type system

* no exception
* no null
* no reflection

--

This means:

* no hole in the type system
* less forgettable runtime checks (try/catch, `if(x == null)`)
* more informative signature

---
# Cost of functional programming

--

* lost the ability to affect the external world

--

* reconsider most algorithms an data structures (no mutation)

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9"
    });
</script>
</body>
</html>