<!DOCTYPE html>
<html>
<head>
<title>Error Handling</title>
<meta charset="utf-8">
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
font-family: 'Yanone Kaffeesatz';
font-weight: normal;
}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: center, middle

# Error Handling
`@JulienTruffaut`

---
# Error Handling

* `Option`
* `Either`
* `Validation`

???
fp => no exception, no null


---
# Option

* An `Option` is a `None` or a `Some`
* a `None` is equivalent to `Unit`
* a `Some[A]` is equivalent to `A`

--

```tut:silent
sealed trait Option[A]

object Option {
  case class None[A]() extends Option[A]
  case class Some[A](value: A) extends Option[A]
}
```

--

```haskell
data Option a = None | Some a
```

---
# Option in stdlib

```tut:silent
sealed trait Option[+A]

case object None extends Option[Nothing]

case class Some[+A](x: A) extends Option[A]
```

???
Use variance `+A` / `Nothing`

`None` and `Some` are top level

---
# Option usage

An `Option` is great way to encode something that can fail for a **SINGLE OBVIOUS** reason.

An `Option` **CANNOT** describe in any way why a failure occurred.

--

## Examples

* lookup something in a data structure / storage

---
# Exercise 1: getUser

```tut:silent
case class User(id: Int, name: String)

def getUser(id: Int, users: List[User]): Option[User] = ???
```

---
# Exercise 1: getUser

```tut:reset:silent
case class User(id: Int, name: String)

def getUser(id: Int, users: List[User]): Option[User] =
  users match {
    case Nil     => None
    case x :: xs =>
      if(x.id == id) Some(x)
      else getUser(id, xs)
  }
```

---
# Exercise 1: getUser

```tut:silent
case class User(id: Int, name: String)

def getUser(id: Int, users: List[User]): Option[User] =
  users.find(_.id == id)
```

--

```tut:silent
val users = List(
  User(1, "John"),
  User(5, "Alice"),
  User(3, "Natalie")
)
```

```tut
getUser(3, users)
getUser(2, users)
```

---
# Exercise 1: getUser

```tut:silent
case class User(id: Int, name: String)

def getUser(id: Int, users: List[User]): Option[User] =
  users.filter(_.id == id) match {
    case Nil         => None    // no user matching
    case x :: Nil    => Some(x) // one user matching
    case _ :: _ :: _ => None    // several users matching
  }
```

---
# Exercise 2: charToDigit

```tut:silent
def charToDigit(c: Char): Option[Int] = ???
```

---
# Exercise 2: charToDigit

```tut:silent
val charToDigitMapping: Map[Char, Int] = Map(
  '0' -> 0,
  '1' -> 1,
  '2' -> 2,
  '3' -> 3,
  '4' -> 4,
  '5' -> 5,
  '6' -> 6,
  '7' -> 7,
  '8' -> 8,
  '9' -> 9
)

def charToDigit(c: Char): Option[Int] =
  charToDigitMapping.get(c)
```

---
# Exercise 2: charToDigit

```tut:silent
import eu.timepit.refined._
import eu.timepit.refined.api.Refined
import eu.timepit.refined.auto._
import eu.timepit.refined.numeric._

type Digit = Int Refined Interval.Closed[W.`0`.T, W.`9`.T]

def charToDigit_v2(c: Char): Option[Digit] = ???
```

---
# Exercise 2: charToDigit

```tut:silent

val charToDigitMapping: Map[Char, Digit] = Map(
  '0' -> 0,
  '1' -> 1,
  '2' -> 2,
  '3' -> 3,
  '4' -> 4,
  '5' -> 5,
  '6' -> 6,
  '7' -> 7,
  '8' -> 8,
  '9' -> 9
)

def charToDigit_v2(c: Char): Option[Digit] =
  charToDigitMapping.get(c)
```

--

```tut:silent
def charToDigit(c: Char): Option[Int] =
  charToDigit_v2(c).map(_.value)
```


---
# Exercise 3: Form

```tut:silent
sealed trait Form
object Form {
  case class Rectangle(width: Int, height: Int) extends Form
  case class Circe(radius: Int) extends Form
}

def asRectangle(form: Form): Option[Form.Rectangle] = ???

def asCircle(form: Form): Option[Form.Circe] = ???
```

---
# Exercise 3: Form

```tut:silent
sealed trait Form
object Form {
  case class Rectangle(width: Int, height: Int) extends Form
  case class Circle(radius: Int) extends Form
}

import Form._

def asRectangle(form: Form): Option[Rectangle] = form match {
  case x: Rectangle => Some(x)
  case _: Circle    => None
}

def asCircle(form: Form): Option[Circle] = form match {
  case _: Rectangle => None
  case x: Circle    => Some(x)
}
```

---
# Exercise 4: Combining Option

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] = ???
```

such as

```tut:silent
val rectangle = Rectangle(3, 4)
val circle    = Circle(5)
```

```scala
asRectangles(rectangle, rectangle) == Some((rectangle, rectangle))
asRectangles(circle   , rectangle) == None
asRectangles(rectangle, circle   ) == None
asRectangles(circle   , circle   ) == None
```

---
# Exercise 4: Combining Option

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] = (f1, f2) match {
  case (x: Rectangle, y: Rectangle) => Some((x, y))
  case (x: Circle   , y: Rectangle) => None
  case (x: Rectangle, y: Circle)    => None
  case (x: Circle   , y: Circle)    => None
}
```

```tut
asRectangles(rectangle, rectangle)
asRectangles(circle   , rectangle)
asRectangles(rectangle, circle   )
asRectangles(circle   , circle   )
```

???
* not scalable
* does not reuse asRectangle


---
# Exercise 4: Combining Option

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  asRectangle(f1) match {
    case None     => None
    case Some(r1) => asRectangle(f2) match {
      case None     => None
      case Some(r2) => Some((r1, r2))
    }
  }
```

```tut
asRectangles(rectangle, rectangle)
asRectangles(circle   , rectangle)
asRectangles(rectangle, circle   )
asRectangles(circle   , circle   )
```

---
# Exercise 4: Combining Option with map2

```tut:silent
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] = ???
```

such as

```scala
map2(Some(3), Some(4))((a, b) => a + b) == Some(7)
map2(Some(3), None   )((a, b) => a + b) == None
map2(None   , Some(3))((a, b) => a + b) == None
map2(None   , None   )((a, b) => a + b) == None
```

---
# Exercise 4: Combining Option with map2

```tut:silent
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] =
  (fa, fb) match {
    case (Some(a), Some(b)) => Some(f(a, b))
    case (Some(_), None   ) => None
    case (None   , Some(_)) => None
    case (None   , None   ) => None
  }
```

```tut
map2(Some(3), Some(4))((a, b) => a + b)
map2(Some(3), None: Option[Int])((a, b) => a + b)
map2(None: Option[Int], Some(3))((a, b) => a + b)
map2(None: Option[Int], None: Option[Int])((a, b) => a + b)
```

---
# Exercise 4: Combining Option with map2

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  map2(asRectangle(f1), asRectangle(f2))((r1, r2) => (r1, r2))
```

```tut
asRectangles(rectangle, rectangle)
asRectangles(circle   , rectangle)
asRectangles(rectangle, circle   )
asRectangles(circle   , circle   )
```

---
# Exercise 4: Combining Option with tuple2

```tut:silent
def tuple2[A, B](fa: Option[A], fb: Option[B]): Option[(A, B)] = ???
```

---
# Exercise 4: Combining Option with tuple2

```tut:silent
def tuple2[A, B](fa: Option[A], fb: Option[B]): Option[(A, B)] =
  map2(fa, fb)((a, b) => (a, b))
```

--

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  tuple2(asRectangle(f1), asRectangle(f2))
```

---
# Exercise 4: Combining Option with map / flatMap

```tut:silent
def map    [A, B](fa: Option[A])(f: A =>        B ): Option[B] = ???
def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = ???
```

such as

```scala
map(Some(3))(i => i + 1) == Some(4)
map(None   )(i => i + 1) == None

flatMap(Some(3))(i => Some(i + 1)) == Some(4)
flatMap(Some(3))(i => None       ) == None
flatMap(None   )(i => Some(i + 1)) == None
```

---
# Exercise 4: Combining Option with map / flatMap

```tut:silent
def map[A, B](fa: Option[A])(f: A => B): Option[B] =
  fa match {
    case None    => None
    case Some(a) => Some(f(a))
  }

def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] =
  fa match {
    case None    => None
    case Some(a) => f(a)
  }
```

```tut
map(Some(3))(i => i + 1) == Some(4)
map(None: Option[Int])(i => i + 1) == None

flatMap(Some(3))(i => Some(i + 1)) == Some(4)
flatMap(Some(3))(i => None) == None
flatMap(None: Option[Int])(i => Some(i + 1)) == None
```

---
# Exercise 4: Combining Option with map / flatMap

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  flatMap(asRectangle(f1))(r1 =>
    map(asRectangle(f2))(r2 => (r1, r2))
  )
```

```tut
asRectangles(rectangle, rectangle)
asRectangles(circle   , rectangle)
asRectangles(rectangle, circle   )
asRectangles(circle   , circle   )
```

---
# Exercise 4: Combining Option with for comprehension

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  for {
    r1 <- asRectangle(f1)
    r2 <- asRectangle(f2)
  } yield (r1, r2)
```

```tut:silent
def asRectangles(f1: Form, f2: Form): Option[(Rectangle, Rectangle)] =
  flatMap(asRectangle(f1))(r1 =>
    map(asRectangle(f2))(r2 => (r1, r2))
  )
```

---
# Exercise 4: map using flatMap

```tut:silent
def map[A, B](fa: Option[A])(f: A => B): Option[B] = ???
```

---
# Exercise 4: map using flatMap

```tut:silent
def map[A, B](fa: Option[A])(f: A => B): Option[B] =
  flatMap(fa)(a => Some(f(a)))
```

---
# Exercise 4: map2 using flatMap

```tut:silent
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] = ???
```

---
# Exercise 4: map2 using flatMap

```tut:silent
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] =
  flatMap(fa)(a => map(fb)(b => f(a, b)))
```

--

```tut:silent
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] =
  for {
    a <- fa
    b <- fb
  } yield f(a, b)
```

---
# Option combination

```tut:silent
def map[A, B](fa: Option[A])(f: A => B): Option[B] = ???
def map2[A, B, C](fa: Option[A], fb: Option[B])(f: (A, B) => C): Option[C] = ???
def tuple2[A, B](fa: Option[A], fb: Option[B]): Option[(A, B)] = ???
def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = ???
```

```scala
flatMap --> map
        --> map2 --> tuple2
```

--

```scala
flatMap --> map2 --> tuple2
                 \-> map
```

--

```tut:silent
def map[A, B](fa: Option[A])(f: A => B): Option[B] =
  map2(fa, Some(()))((a, _) => f(a))
```

---
# Either

* An `Either` is a `Left` or a `Right`
* a `Left[E]` is equivalent to `E`
* a `Right[A]` is equivalent to `A`

--

```tut:silent
sealed trait Either[E, A]

object Option {
  case class Left [E, A](value: E) extends Either[E, A]
  case class Right[E, A](value: A) extends Either[E, A]
}
```

--

```haskell
data Either e a = Left e | Right a
```

---
# Either usage

An `Either` allows to encode failure in **MULTIPLE** ways.

An `Either` is like an `Option` where we can describe the failure.

--

## Examples

* ...

---
## Option as an Either


```haskell
data Option   a = None   | Some  a
data Either e a = Left e | Right a
```

--

```scala
type Option[A] = Either[Unit, A]
```

---
# Exercise 5: getUser_v2

```tut:reset:silent
case class User(id: Int, name: String)

sealed trait GetUserError

def getUser_v2(id: Int, users: List[User]): Either[GetUserError, User] = ???
```

---
# Exercise 5: getUser_v2

```tut:silent
import cats.data.NonEmptyList

sealed trait GetUserError
object GetUserError {
  case object NoUserMatching extends GetUserError
  case class NonUniqueUserId(users: NonEmptyList[User]) extends GetUserError
}

def getUser_v2(id: Int, users: List[User]): Either[GetUserError, User] = ???
```

---
# Exercise 5: getUser_v2

```tut:silent
sealed trait GetUserError
object GetUserError {
  case object NoUserMatching extends GetUserError
  case class NonUniqueUserId(users: NonEmptyList[User]) extends GetUserError
}

import GetUserError._

def getUser_v2(id: Int, users: List[User]): Either[GetUserError, User] =
  users.filter(_.id == id) match {
    case Nil             => Left(NoUserMatching)
    case x :: Nil        => Right(x)
    case x1 :: x2 :: xs  => Left(NonUniqueUserId(NonEmptyList(x1, x2 :: xs)))
  }
```

---
# Exercise 5: getUser_v2

```tut:silent
val users = List(
  User(1, "John"),
  User(5, "Alice"),
  User(3, "Natalie"),
  User(1, "Bob")
)
```

```tut
getUser_v2(3, users)
getUser_v2(2, users)
getUser_v2(1, users)
```

---
# Exercise 6: Validate password

```tut:silent
sealed trait PasswordError

def validatePassword(s: String): Either[PasswordError, Unit] = ???
```

---
# Exercise 6: Validate password

```tut:silent
sealed trait PasswordError
object PasswordError {
  case class NotLongEnough(size: Int) extends PasswordError
  case object NoUpperCase extends PasswordError
  case object NoLowerCase extends PasswordError
  case object NoDigit extends PasswordError
}

import PasswordError._

def checkLength   (s: String): Either[NotLongEnough   , Unit] = ???
def checkUpperCase(s: String): Either[NoUpperCase.type, Unit] = ???
def checkLowerCase(s: String): Either[NoLowerCase.type, Unit] = ???
def checkDigit    (s: String): Either[NoDigit.type    , Unit] = ???

def validatePassword(s: String): Either[PasswordError, Unit] = ???
```

---
# Exercise 6: Validate password

```tut:silent
def checkLength(s: String): Either[NotLongEnough, Unit] = {
  if(s.length < 8) Left(NotLongEnough(s.length))
  else Right(())
}

def checkUpperCase(s: String): Either[NoUpperCase.type, Unit] = {
  s.find(_.isUpper) match {
    case None    => Left(NoUpperCase)
    case Some(_) => Right(())
  }
}

def checkLowerCase(s: String): Either[NoLowerCase.type, Unit] = {
  s.find(_.isLower) match {
    case None    => Left(NoLowerCase)
    case Some(_) => Right(())
  }
}

def checkDigit(s: String): Either[NoDigit.type, Unit] = {
  s.find(_.isDigit) match {
    case None    => Left(NoDigit)
    case Some(_) => Right(())
  }
}
```

---
# Exercise 6: Validate password

```tut:silent
def contains[E](s: String, p: Char => Boolean, e: E): Either[E, Unit] = {
  s.find(p) match {
    case None    => Left(e)
    case Some(_) => Right(())
  }
}
```

--

```tut:silent
def checkUpperCase(s: String): Either[NoUpperCase.type, Unit] =
  contains(s, _.isUpper, NoUpperCase)

def checkLowerCase(s: String): Either[NoLowerCase.type, Unit] =
  contains(s, _.isLower, NoLowerCase)

def checkDigit(s: String): Either[NoDigit.type, Unit] =
  contains(s, _.isDigit, NoDigit)
```

???
Note that checkLowerCase must use NoLowerCase as `e` because it is the only value this type

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def flatMap[   A, B](fa:    Option[A])(f: A =>    Option[B]):    Option[B] = ???
def flatMap[E, A, B](fa: Either[E, A])(f: A => Either[E, B]): Either[E, B] = ???
```

--

```scala
validatePassword = checkLength flatMap checkUpperCase flatMap checkLowerCase flatMap checkDigit
```

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def flatMap[E, A, B](fa: Either[E, A])(f: A => Either[E, B]): Either[E, B] = ???
```

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def flatMap[E, A, B](fa: Either[E, A])(f: A => Either[E, B]): Either[E, B] = fa match {
  case Left(e)  => Left(e)
  case Right(a) => f(a)
}
```

---
# Exercise 6: Validate password (flatMap)

```scala
validatePassword = checkLength flatMap checkUpperCase flatMap checkLowerCase flatMap checkDigit
```

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] = ???
```

---
# Exercise 6: Validate password (flatMap)

```tut:fail
def validatePassword(s: String): Either[PasswordError, Unit] =
  flatMap(checkLength(s))(_ =>
    flatMap(checkUpperCase(s))(_ =>
      flatMap(checkLowerCase(s))(_ =>
        checkDigit(s)
      )
    )
  )
```

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def checkLength(s: String): Either[NotLongEnough, Unit] = {
  if(s.length < 8) Left(NotLongEnough(s.length))
  else Right(())
}

def checkUpperCase(s: String): Either[NoUpperCase.type, Unit] =
  contains(s, _.isUpper, NoUpperCase)

def checkLowerCase(s: String): Either[NoLowerCase.type, Unit] =
  contains(s, _.isLower, NoLowerCase)

def checkDigit(s: String): Either[NoDigit.type, Unit] =
  contains(s, _.isDigit, NoDigit)
```

```tut:silent
def flatMap[E, A, B](fa: Either[E, A])(f: A => Either[E, B]): Either[E, B] = ???
```

---
# Sum type encoding


```tut:silent
sealed trait Foo
object Foo {
  case class FooInt(x: Int) extends Foo
  case class FooBool(x: Boolean) extends Foo
}
```

```tut
Foo.FooInt(5)
Foo.FooInt(5): Foo
```

## Haskell

```haskell
data Foo = FooInt Int | FooBool Bool
```

```haskell
λ> FooInt 5
λ> FooInt 5 :: Foo
```

---
# Exercise 6: Combining Either (up-casting)

```tut
checkLength("foo")

checkLength("foo"): Either[PasswordError, Unit]
```

--

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  flatMap(checkLength(s): Either[PasswordError, Unit])(_ =>
    flatMap(checkUpperCase(s): Either[PasswordError, Unit])(_ =>
      flatMap(checkLowerCase(s): Either[PasswordError, Unit])(_ =>
        checkDigit(s))))
```

---
# Exercise 6: Combining Either (up-casting)


```tut:silent
def leftMap[E, A, F](fa: Either[E, A])(f: E => F): Either[F, A] = fa match {
  case  Left(e) => Left(f(e))
  case Right(a) => Right(a)
}

def liftE[E, A, F >: E](fa: Either[E, A]): Either[F, A] =
  leftMap(fa)(e => e: F)
```

--

```tut:invisible
implicit class EitherLiftE[E, A](self: Either[E, A]){
  def liftE[F >: E]: Either[F, A] =
    leftMap(self)(e => e: F)
}
```

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  flatMap(checkLength(s).liftE[PasswordError])(_ =>
    flatMap(checkUpperCase(s).liftE[PasswordError])(_ =>
      flatMap(checkLowerCase(s).liftE[PasswordError])(_ =>
        checkDigit(s))))
```

---
# Exercise 6: Combining Either (smart constructor)

```tut:silent
def checkLength(s: String): Either[PasswordError, Unit] = {
  if(s.length < 8) Left(NotLongEnough(s.length))
  else Right(())
}

def checkUpperCase(s: String): Either[PasswordError, Unit] =
  contains(s, _.isUpper, NoUpperCase)

def checkLowerCase(s: String): Either[PasswordError, Unit] =
  contains(s, _.isLower, NoLowerCase)

def checkDigit(s: String): Either[PasswordError, Unit] =
  contains(s, _.isDigit, NoDigit)
```

--

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  flatMap(checkLength(s))(_ =>
    flatMap(checkUpperCase(s))(_ =>
      flatMap(checkLowerCase(s))(_ =>
        checkDigit(s))))
```

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  flatMap(checkLength(s))(_ =>
    flatMap(checkUpperCase(s))(_ =>
      flatMap(checkLowerCase(s))(_ =>
        checkDigit(s))))
```

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  for {
    _ <- checkLength(s)
    _ <- checkUpperCase(s)
    _ <- checkLowerCase(s)
    _ <- checkDigit(s)
  } yield ()
```

???
for-comprehension type inference is somehow better such as we could have used our previous error encoding

---
# Exercise 6: Validate password (flatMap)

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  for {
    _ <- checkLength(s)
    _ <- checkUpperCase(s)
    _ <- checkLowerCase(s)
    _ <- checkDigit(s)
  } yield ()
```

```tut
validatePassword("abcdefG1")
validatePassword("foo")
validatePassword("hellllllllll12")
validatePassword("hellllllllllOO")
validatePassword("HELLLLLLLOO1234")
```

???
flatMap / for-comprehension defines a sequential calculation

do 1, once use have result of 1 do 2, once you have the result of 2 do 3 ...

here we do not need to perform our checks sequentially, they don't depend on each other!

---
# Exercise 6: Validate password (map4)

```scala
validatePassword = checkLength /\ checkUpperCase /\ checkLowerCase /\ checkDigit
```

```tut:silent
def map4[E, A1, A2, A3, A4, B](
  fa: Either[E, A1],
  fb: Either[E, A2],
  fc: Either[E, A3],
  fd: Either[E, A4])(
  f: (A1, A2, A3, A4) => B
): Either[E, B] = ???
```

--

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  map4(checkLength(s), checkUpperCase(s), checkLowerCase(s), checkDigit(s))(
    (_,_,_,_) => ()
  )
```

---
# Exercise 6: Validate password (map2)

```tut:silent
def map2[   A, B, C](fa: Option[   A], fb: Option[   B])(f: (A, B) => C) = ???
def map2[E, A, B, C](fa: Either[E, A], fb: Either[E, B])(f: (A, B) => C) = ???
```

---
# Exercise 6: Validate password (map2)

```tut:silent
def map2[E, A1, A2, B](fa: Either[E, A1], fb: Either[E, A2])(f: (A1, A2) => B): Either[E, B] =
  (fa, fb) match {
     case (Right(a), Right(b)) => ???
     case ( Left(e), Right(b)) => ???
     case (Right(a),  Left(e)) => ???
     case (Left(e1), Left(e2)) => ???
  }
```

---
# Exercise 6: Validate password (map2)

```tut:silent
def map2[E, A1, A2, B](fa: Either[E, A1], fb: Either[E, A2])(f: (A1, A2) => B): Either[E, B] =
  (fa, fb) match {
     case (Right(a), Right(b)) => Right(f(a, b))
     case ( Left(e), Right(_)) => Left(e)
     case (Right(_),  Left(e)) => Left(e)
     case (Left(e1), Left(e2)) => ???
  }
```

???
We are forced to implement the first 3 cases this way
we have no freedom! ==> we don't need to test these cases

---
# Exercise 6: Validate password (map2)

```tut:silent
def map2[E, A1, A2, B](fa: Either[E, A1], fb: Either[E, A2])(f: (A1, A2) => B): Either[E, B] =
  (fa, fb) match {
     case (Right(a), Right(b)) => Right(f(a, b))
     case ( Left(e), Right(_)) => Left(e)
     case (Right(_),  Left(e)) => Left(e)
     case ( Left(e),  Left(_)) => Left(e)
  }
```

---
# Exercise 6: Validate password (map3)

```tut:silent
def map3[E, A1, A2, A3, B](
  fa: Either[E, A1],
  fb: Either[E, A2],
  fc: Either[E, A3])(
  f: (A1, A2, A3) => B
): Either[E, B] = ???
```

---
# Exercise 6: Validate password (map3)

```tut:silent
def tuple2[E, A1, A2](fa: Either[E, A1], fb: Either[E, A2]): Either[E, (A1, A2)] =
  map2(fa, fb)((a1,a2) => (a1,a2))
```

--

```tut:silent
def map3[E, A1, A2, A3, B](
  fa: Either[E, A1],
  fb: Either[E, A2],
  fc: Either[E, A3])(
  f: (A1, A2, A3) => B
): Either[E, B] =
  map2(fa, tuple2(fb, fc)){ case (a, (b, c)) => f(a,b,c) }
```

---
# Exercise 6: Validate password (map4)

```tut:silent
def map4[E, A1, A2, A3, A4, B](
  fa: Either[E, A1],
  fb: Either[E, A2],
  fc: Either[E, A3],
  fd: Either[E, A4])(
  f: (A1, A2, A3, A4) => B
): Either[E, B] =
  map2(tuple2(fa, fb), tuple2(fc, fd)){ case ((a, b), (c, d)) => f(a,b,c,d) }
```

```tut:silent
def validatePassword(s: String): Either[PasswordError, Unit] =
  map4(checkLength(s), checkUpperCase(s), checkLowerCase(s), checkDigit(s))(
    (_,_,_,_) => ()
  )
```

---
# Validation

* a `Validation` is an `Invalid` or a `Valid`
* a `Invalid[E]` is equivalent to `E`
* a `Valid[A]` is equivalent to `A`

--

```tut:silent
sealed trait Validation[E, A]

object Validation {
  case class Invalid[E, A](value: E) extends Validation[E, A]
  case class   Valid[E, A](value: A) extends Validation[E, A]
}
```

---
# Validation - Either

A `Validation` is an `Either` with different names

```haskell
data Either     e a = Left    e | Right   a
data Validation e a = Invalid e | Invalid a
```




</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9"
    });
</script>
</body>
</html>