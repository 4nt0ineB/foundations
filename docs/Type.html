<!DOCTYPE html>
<html>
<head>
<title>Type</title>
<meta charset="utf-8">
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
font-family: 'Yanone Kaffeesatz';
font-weight: normal;
}
.pull-left {
float: left;
width: 47%;
}
.pull-right {
float: right;
width: 47%;
}
table {
  border-collapse: collapse;
  display: inline-block;
}
th, td {
  padding: 10px;
  border: 1px solid black;
}
tr:nth-child(even) {background-color: #f2f2f2;}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: center, middle

# Type
Foundation of Functional Programming
<br>
<br>
`@JulienTruffaut`

---
background-image: url(img/types-1.jpg)

# Type

---
background-image: url(img/types-1-bis.jpg)

# Type cardinality

---
class: center, middle

# Cardinality of a type should **exactly** fit business requirement

---
# Type too big: |String| > # Country

```scala
def getCurrency(country: String): String =
  country match {
    case "France" | "Germany" => "EUR"
    case "United Kingdom"     => "GBP"
    case "Switzerland"        => "CHF"
    case _                    => ???
  }
```

---
# Type too big: |String| > # Country

```scala
def getCurrency(country: String): Option[String] =
  country match {
    case "France" | "Germany" => Some("EUR")
    case "United Kingdom"     => Some("GBP")
    case "Switzerland"        => Some("CHF")
    case _                    => None
  }
```

---
# Type just right

```scala
sealed trait Country

case object France        extends Country
case object Germany       extends Country
case object UnitedKingdom extends Country
case object Switzerland   extends Country

def getCurrency(country: Country): String =
  country match {
    case France | Germany => "EUR"
    case UnitedKingdom    => "GBP"
    case Switzerland      => "CHF"
  }
```

---
# Type too big

```scala
case class Person(name: String, streetNumber: Option[Int], streetName: Option[String])

def fullAddress(person: Person): Option[String] =
  (person.streetNumber, person.streetName) match {
    case (Some(x), Some(y)) => Some(s"$x $y")
    case (Some(x),    None) => ???
    case (   None, Some(y)) => ???
    case (None   , None   ) => None
  }
```

---
# Type just right

```scala
case class Address(streetNumber: Int, streetName: String)
case class Person(name: String, address: Option[Address])

def fullAddress(address: Address): String =
  s"${address.streetNumber} ${address.streetName}"

def fullPersonAddress(person: Person): Option[String] =
  person.address.map(fullAddress)
```

---
# Type too big

```scala
case class Item(id: String, quantity: Int, price: Double)

// order must have at least one item
case class Order(id: String, items: List[Item]){
  def total: Double =
    items.map(i => i.quantity * i.price).sum
}
```

--

```scala
def halfPriceFirstItem(order: Order): Order = {
  val firstItem = order.items.head
  val discounted = firstItem.copy(price = firstItem.price * 0.5)
  order.copy(items = discounted :: order.items.tail)
}
```

---
# Type too big

```scala
case class Item(id: String, quantity: Int, price: Double)

// order must have at least one item
case class Order(id: String, items: List[Item]){
  def total: Double =
    items.map(i => i.quantity * i.price).sum
}
```

```scala
def halfPriceFirstItem(order: Order): Order = {
  order.items match {
    case Nil     => ???
    case x :: xs =>
      val discounted = x.copy(price = x.price * 0.5)
      order.copy(items = discounted :: xs)
  }
}
```

---
# Type just right

```scala
import cats.data.NonEmptyList
import cats.implicits._

case class Item(id: String, quantity: Int, price: Double)

case class Order(id: String, items: NonEmptyList[Item]){
  def total: Double =
    items.foldMap(i => i.quantity * i.price)
}
```

```scala
def halfPriceFirstItem(order: Order): Order = {
  val firstItem  = order.items.head
  val discounted = firstItem.copy(price = firstItem.price * 0.5)
  order.copy(items = NonEmptyList(discounted, order.items.tail))
}
```


---
# Type too small

```scala
import java.util.Date
```

```scala
scala> val fifthMarch = new Date(1551818168101L) // milliseconds precision
fifthMarch: java.util.Date = Tue Mar 05 21:36:08 CET 2019
```

--

```scala
scala> List(1,2,3,4).size //Int.MaxValue limit
res2: Int = 4
```

--

```scala
def parseJson(json: String): Option[Json] = ??? // no error description
```

---
background-image: url(img/function.jpg)

# Function

---
class: center, middle

# A => B

---
class: center, middle

```scala
val isEven: Int => Boolean =
  x => x % 2 == 0

val increment: Int => Int =
  x => x + 1
```

---
class: center, middle

# Type is a set

--

# &&

# A => B is a type

---
background-image: url(img/A-to-B-set-1.jpg)

# A => B is a set!

---
background-image: url(img/int-to-int-type-1.jpg)

# Function is a set!

---
class: center, middle

# |A => B| represents how many implementations exist

---
class: center, middle

# The smaller |A => B|, the better

---
# The smaller |A => B|, the better

```scala
def getCurrency1(country: String ): Option[String] = ???

def getCurrency2(country: Country): String = ???
```

--

```scala
|getCurrency2| < |getCurrency1|
```

---
class: center, middle

# How to calculate |A => B| ?

---
class: center, middle

# Exercises

---
# Type Algebra


.center[
| Type        | Algebra   |
|:-----------:| :--------:|
|Nothing      | 0         |
|Unit         | 1         |
|Either[A, B] | A + B     |
|(A, B)       | A * B     |
| A => B      | B ^ A     |
| Isomorphism | A == B    |
]

---
class: center, middle

# Curry–Howard isomorphism

[Propositions as types](https://www.youtube.com/watch?v=IOiZatlZtGU) from Philip Wadler


---
# Type Algebra Logic

.center[
| Type        | Algebra   | Logic                 |
|:-----------:| :--------:|:---------------------:|
|Nothing      | 0         | ⊥ (false)             |
|Unit         | 1         | ⊤ (true)              |
|Either[A, B] | A + B     | A ∨ B (or)            |
|(A, B)       | A * B     | A ∧ B (and)           |
| A => B      | B ^ A     | B → A (implies)       |
| Isomorphism | A == B    | A ⇔ B (equivalence)   |
]

---
# Type Algebra Logic

.center[
| Type        | Algebra   | Logic |
|:-----------:| :--------:|:-----:|
|Nothing      | 0         | ⊥     |
|Unit         | 1         | ⊤     |
|Either[A, B] | A + B     | A ∨ B |
|(A, B)       | A * B     | A ∧ B |
| A => B      | B ^ A     | B → A |
| Isomorphism | A == B    | A ⇔ B |
]

---
class: center, middle

```scala
Either[A, Nothing] == A
```

--

```scala
A ∨ ⊥ ⇔ A
```

---
class: center, middle

```scala
(A, Nothing) == Nothing
```

--

```scala
A ∧ ⊥ ⇔ ⊥
```


</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9",
        slideNumberFormat: '%current%'
    });
</script>
</body>
</html>
